// Load the full build.
import _ from 'lodash';

var deck = [];
var CardsFolders = ["Clubs", "Diamonds", "Hearts", "Spades"]; //C=Clubs  D=Diamonds H=Hearts S=Spades
var cardWeights = [
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "10",
  "J",
  "Q",
  "K",
  "A"
];

(function getDeck() {

  for (const y of CardsFolders) {
    for (const x of cardWeights) {
      const card = {
        Value: x,
        Suit: y
      };
      deck.push(card);
    }
  }
  deck = _.shuffle(deck);
  return deck;
}());

function getCards() {
  let usr_cards = [];
  for (let i = 0; i <= 4; i++) {
    usr_cards.push(deck[i]);
    deck = _.pull(deck, deck[i]);
  }

  usr_cards = _.sortBy(usr_cards, function(obj) {
    return _.indexOf(cardWeights, obj.Value);
  });
  //  console.log(usr_cards);
  return usr_cards;
}

class Player {
  constructor(name) {
    this.name = name;
    this.cards = getCards();
    this.ranktype = this.handsCheck();
    this.pot = "120";
  }
}

Player.prototype.flush_check = function() {

  //obj to Array
  const array = Array.from(this.cards);

  for (const el of array) {
    if (array[0].Suit !== el.Suit)
      return false;
    }
  return true;

}

Player.prototype.royal_flush = function() {
  const royal = ['10', 'J', 'Q', 'K', 'A'];

  ///alternative flush check implementation using unique Suits
  const numSuit = _.uniqBy(this.cards, function(x) {
    return x.Suit;
  });

  if (numSuit != 1)
    return false;

  ///

  for (const rank of this.cards) {

    if (royal.shift() !== rank.Value) {
      return false;
    }
  }
  return true;

}

Player.prototype.straightCheck = function() {

  let index = _.indexOf(cardWeights, this.cards[0].Value);

  for (const card of this.cards) {
    if (card.Value != cardWeights[index]) {
      return false;
    }
    index++;
  }
  return true;

}

Player.prototype.straight_flush_Check = function() {

  const numSuit = _.uniqBy(this.cards, function(x) {
    return x.Suit;
  });

  let index = _.indexOf(cardWeights, this.cards[0].Value);

  for (const card of this.cards) {
    if (card.Value != cardWeights[index]) {
      return false;
    }
    index++;
  }
  if (numSuit.length == 1) {
    return true;
  }

}

Player.prototype.pairsCheck = function() {
  ///inserting count property in the object

  let filteredArray = _.cloneDeep(this.cards);
  for (const el of filteredArray) {
    el.cnt = 0;
  }

  for (const outer of filteredArray) {
    for (const inner of filteredArray) {
      if (outer.Value == inner.Value)
        inner.cnt = inner.cnt + 1;
      }

  }

  filteredArray = _.uniqBy(filteredArray, function(x) {
    return x.Value;
  })

  const max = _.maxBy(filteredArray, function(o) {
    return o.cnt;
  });
  //console.log(max);

  if (filteredArray.length == 4) {
    return true;

  } else
    return false;

  }

Player.prototype.handsCheck = function() {

  if (this.royal_flush())
    return "Royal Flush";

  if (this.flush_check())
    return "Flush";

  if (this.straightCheck())
    return "Straight";

  if (this.straight_flush_Check())
    return "Straight flush_check";

  if (this.pairsCheck())
    return "Pairs type";

else
    return "high cards";

  }

var plr1 = new Player("Mike");
console.log(plr1);
